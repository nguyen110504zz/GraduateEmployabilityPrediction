# -*- coding: utf-8 -*-
"""DecisionTree-KFold.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V4rImHVro1leAwmLTC_eekjX7z8bAGo1
"""

from google.colab import files
uploaded = files.upload()

!pip install scikit-learn

#%% - Import thư viện
import pandas as pd
import numpy as np
from sklearn.model_selection import KFold, GridSearchCV, RandomizedSearchCV
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from sklearn.tree import export_graphviz
import graphviz
from io import StringIO

#%% - Đọc data
df = pd.read_csv("model2_data.csv")

#%% - Tách đặc trưng (X) và nhãn (y)
X = df.drop('PlacementStatus', axis=1)
y = df['PlacementStatus']

#%% Tối ưu hóa tham số bằng GridSearchCV
print("Optimizing Decision Tree with GridSearchCV:")
k = 5  # Số fold
param_grid = {
    'max_depth': [3, 5, 10, None],
    'min_samples_split': [2, 5, 10],
    'min_samples_leaf': [1, 2, 4],
    'criterion': ['gini', 'entropy']
}

grid_search = GridSearchCV(DecisionTreeClassifier(random_state=42), param_grid, cv=k, scoring='f1', n_jobs=-1)
grid_search.fit(X, y)

print("Best parameters:", grid_search.best_params_)
print("Best F1-Score:", grid_search.best_score_)

#%% Huấn luyện và đánh giá với tham số tối ưu
best_dt_model = grid_search.best_estimator_
kf = KFold(n_splits=k, shuffle=True, random_state=42)

optimized_accuracy_scores = []
optimized_precision_scores = []
optimized_recall_scores = []
optimized_f1_scores = []
optimized_confusion_matrices = []
models_per_fold = []  # Lưu trữ mô hình đã huấn luyện cho từng fold

print("\nK-Fold Cross Validation (Optimized Decision Tree):")
for fold, (train_index, test_index) in enumerate(kf.split(X), 1):
    X_train, X_test = X.iloc[train_index], X.iloc[test_index]
    y_train, y_test = y.iloc[train_index], y.iloc[test_index]

    # Tạo một mô hình mới với tham số tối ưu
    fold_model = DecisionTreeClassifier(**grid_search.best_params_, random_state=42)
    fold_model.fit(X_train, y_train)
    models_per_fold.append(fold_model)  # Lưu mô hình

    y_pred = fold_model.predict(X_test)

    # Tính toán các chỉ số
    accuracy = accuracy_score(y_test, y_pred)
    precision = precision_score(y_test, y_pred, zero_division=0)
    recall = recall_score(y_test, y_pred, zero_division=0)
    f1 = f1_score(y_test, y_pred, zero_division=0)

    # Tính confusion matrix
    cm = confusion_matrix(y_test, y_pred)
    optimized_confusion_matrices.append(cm)

    # Hiển thị hiệu suất cho từng fold
    print(f"\nFold {fold}:")
    print(f"Accuracy: {accuracy:.4f}")
    print(f"Precision: {precision:.4f}")
    print(f"Recall: {recall:.4f}")
    print(f"F1-Score: {f1:.4f}")
    print("Confusion Matrix:")
    print(cm)

    # Vẽ confusion matrix cho từng fold
    plt.figure(figsize=(6, 4))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
                xticklabels=['Not Placed', 'Placed'],
                yticklabels=['Not Placed', 'Placed'])
    plt.title(f'Confusion Matrix (Optimized) - Fold {fold}')
    plt.xlabel('Predicted')
    plt.ylabel('Actual')
    plt.show()

    # Lưu trữ kết quả
    optimized_accuracy_scores.append(accuracy)
    optimized_precision_scores.append(precision)
    optimized_recall_scores.append(recall)
    optimized_f1_scores.append(f1)

# Tổng hợp kết quả tối ưu
print("\nSummary (Optimized Decision Tree):")
print(f"Accuracy: {np.mean(optimized_accuracy_scores):.4f} ± {np.std(optimized_accuracy_scores):.4f}")
print(f"Precision: {np.mean(optimized_precision_scores):.4f} ± {np.std(optimized_precision_scores):.4f}")
print(f"Recall: {np.mean(optimized_recall_scores):.4f} ± {np.std(optimized_recall_scores):.4f}")
print(f"F1-Score: {np.mean(optimized_f1_scores):.4f} ± {np.std(optimized_f1_scores):.4f}")

# Tổng hợp confusion matrix (cộng tất cả các fold) cho mô hình tối ưu
total_optimized_cm = np.sum(optimized_confusion_matrices, axis=0)
print("\nTotal Confusion Matrix (Optimized, Sum of All Folds):")
print(total_optimized_cm)

# Vẽ total confusion matrix cho mô hình tối ưu
plt.figure(figsize=(6, 4))
sns.heatmap(total_optimized_cm, annot=True, fmt='d', cmap='Blues',
            xticklabels=['Not Placed', 'Placed'],
            yticklabels=['Not Placed', 'Placed'])
plt.title('Total Confusion Matrix (Optimized, All Folds)')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.show()

# ====RANDOM FOREST====
#%% Tối ưu hóa tham số cho Random Forest (dùng RandomizedSearchCV)
print("\nOptimizing Random Forest with RandomizedSearchCV:")
param_dist_rf = {
    'n_estimators': [50, 100, 200, 300, 500],  # Số cây trong rừng
    'max_depth': [3, 5, 10, 20, None],
    'min_samples_split': [2, 5, 10, 20],
    'min_samples_leaf': [1, 2, 4, 8],
    'criterion': ['gini', 'entropy'],
    'max_features': ['auto', 'sqrt', 'log2']  # Số đặc trưng tối đa để xem xét khi chia
}

random_search_rf = RandomizedSearchCV(
    RandomForestClassifier(random_state=42),
    param_distributions=param_dist_rf,
    n_iter=50,  # Số lần thử ngẫu nhiên
    cv=k,
    scoring='f1',
    n_jobs=-1,
    random_state=42
)
random_search_rf.fit(X, y)

print("Best parameters (Random Forest):", random_search_rf.best_params_)
print("Best F1-Score (Random Forest):", random_search_rf.best_score_)

# 5. Huấn luyện và đánh giá Random Forest với tham số tối ưu
best_rf_model = random_search_rf.best_estimator_

rf_accuracy_scores = []
rf_precision_scores = []
rf_recall_scores = []
rf_f1_scores = []
rf_confusion_matrices = []

print("\nK-Fold Cross Validation (Random Forest):")
for fold, (train_index, test_index) in enumerate(kf.split(X), 1):
    X_train, X_test = X.iloc[train_index], X.iloc[test_index]
    y_train, y_test = y.iloc[train_index], y.iloc[test_index]

    best_rf_model.fit(X_train, y_train)
    y_pred = best_rf_model.predict(X_test)

    accuracy = accuracy_score(y_test, y_pred)
    precision = precision_score(y_test, y_pred, zero_division=0)
    recall = recall_score(y_test, y_pred, zero_division=0)
    f1 = f1_score(y_test, y_pred, zero_division=0)

    cm = confusion_matrix(y_test, y_pred)
    rf_confusion_matrices.append(cm)

    print(f"\nFold {fold}:")
    print(f"Accuracy: {accuracy:.4f}")
    print(f"Precision: {precision:.4f}")
    print(f"Recall: {recall:.4f}")
    print(f"F1-Score: {f1:.4f}")
    print("Confusion Matrix:")
    print(cm)

    plt.figure(figsize=(6, 4))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
                xticklabels=['Not Placed', 'Placed'],
                yticklabels=['Not Placed', 'Placed'])
    plt.title(f'Confusion Matrix (Random Forest) - Fold {fold}')
    plt.xlabel('Predicted')
    plt.ylabel('Actual')
    plt.show()

    rf_accuracy_scores.append(accuracy)
    rf_precision_scores.append(precision)
    rf_recall_scores.append(recall)
    rf_f1_scores.append(f1)

# Tổng hợp kết quả Random Forest
print("\nSummary (Random Forest):")
print(f"Accuracy: {np.mean(rf_accuracy_scores):.4f} ± {np.std(rf_accuracy_scores):.4f}")
print(f"Precision: {np.mean(rf_precision_scores):.4f} ± {np.std(rf_precision_scores):.4f}")
print(f"Recall: {np.mean(rf_recall_scores):.4f} ± {np.std(rf_recall_scores):.4f}")
print(f"F1-Score: {np.mean(rf_f1_scores):.4f} ± {np.std(rf_f1_scores):.4f}")

total_rf_cm = np.sum(rf_confusion_matrices, axis=0)
print("\nTotal Confusion Matrix (Random Forest, Sum of All Folds):")
print(total_rf_cm)

plt.figure(figsize=(6, 4))
sns.heatmap(total_rf_cm, annot=True, fmt='d', cmap='Blues',
            xticklabels=['Not Placed', 'Placed'],
            yticklabels=['Not Placed', 'Placed'])
plt.title('Total Confusion Matrix (Random Forest, All Folds)')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.show()

